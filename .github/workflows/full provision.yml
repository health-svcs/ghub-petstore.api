name: Provision EC2 + Build & Deploy API

on:
  workflow_dispatch:
    inputs:
      APP_NAME:
        description: "App label for DNS/ECR (petstore.api, verademo.api, etc)"
        required: false
        default: "petstore.api"
        type: string

      SA_ACRONYM:
        description: "3-letter SA acronym for stable DNS (agc, elg, etc)"
        required: true
        default: "agc"
        type: string

      TlsMode:
        description: "TLS posture applied at deploy time (NGINX): Weak or Secure"
        required: true
        default: "Weak"
        type: choice
        options: [Weak, Secure]

  push:
    branches: ["main"]

env:
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ vars.AWS_REGION }}

  # Single source of truth (per repo via APP_NAME_DEFAULT)
  APP_NAME: ${{ inputs.APP_NAME || vars.APP_NAME_DEFAULT }}

  # ECR repo name: must be valid (no dots). We'll sanitize later and use SANITIZED_ECR_REPO.
  ECR_REPO_RAW: ${{ inputs.APP_NAME || vars.APP_NAME_DEFAULT }}

  IMAGE_TAG: ${{ github.run_id }}
  TEMPLATE_FILE: cloudformation/ec2.yaml

  DEMO_OWNER: ${{ vars.DEMO_OWNER || github.actor }}

  SA_ACRONYM: ${{ inputs.SA_ACRONYM || vars.SA_ACRONYM_DEFAULT }}
  TLS_MODE: ${{ inputs.TlsMode || vars.TLSMODE_DEFAULT || 'Weak' }}

  HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID_SA }}
  DNS_BASE_DOMAIN: ${{ vars.SA_BASE_DOMAIN }}  # sa.livedemo-us.com
  DNS_TTL: ${{ vars.DNS_TTL || '60' }}

jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Validate required repo/org variables
        shell: bash
        run: |
          set -euo pipefail
          require() { local n="$1"; local v="$2"; [[ -n "${v}" ]] || { echo "ERROR: '${n}' is empty"; exit 1; }; }

          require "AWS_ACCOUNT_ID" "${AWS_ACCOUNT_ID}"
          require "AWS_REGION" "${AWS_REGION}"
          require "AWS_ROLE_TO_ASSUME" "${{ vars.AWS_ROLE_TO_ASSUME }}"
          require "AMI_ID" "${{ vars.AMI_ID }}"
          require "INSTANCE_TYPE" "${{ vars.INSTANCE_TYPE }}"
          require "SUBNET_ID" "${{ vars.SUBNET_ID }}"
          require "SG_IDS" "${{ vars.SG_IDS }}"
          require "INSTANCE_PROFILE_NAME" "${{ vars.INSTANCE_PROFILE_NAME }}"
          require "KEY_NAME" "${{ vars.KEY_NAME }}"

          require "APP_NAME_DEFAULT" "${{ vars.APP_NAME_DEFAULT }}"
          require "SA_ACRONYM_DEFAULT" "${{ vars.SA_ACRONYM_DEFAULT }}"
          require "HOSTED_ZONE_ID_SA" "${{ vars.HOSTED_ZONE_ID_SA }}"
          require "SA_BASE_DOMAIN" "${{ vars.SA_BASE_DOMAIN }}"

          echo "Resolved APP_NAME=${APP_NAME}"
          echo "Resolved SA_ACRONYM=${SA_ACRONYM}"
          echo "Resolved TLS_MODE=${TLS_MODE}"
          echo "Resolved DEMO_OWNER=${DEMO_OWNER}"

          if [[ "${DEMO_OWNER}" == "github-actions" || "${DEMO_OWNER}" == *"[bot]" ]]; then
            echo "ERROR: Refusing to provision for automation actor: ${DEMO_OWNER}"
            exit 1
          fi

  provision-ec2-cfn:
    runs-on: ubuntu-latest
    needs: validate-inputs
    permissions:
      id-token: write
      contents: read
    outputs:
      instance_id: ${{ steps.cfnout.outputs.instance_id }}
      public_ip: ${{ steps.pubip.outputs.public_ip }}
      dns_name: ${{ steps.dns.outputs.dns_name }}
      dast_url: ${{ steps.dns.outputs.dast_url }}
      ecr_repo: ${{ steps.names.outputs.ecr_repo }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Derive safe names (Stack + ECR)
        id: names
        shell: bash
        run: |
          set -euo pipefail

          # StackName rules: [a-zA-Z][-a-zA-Z0-9]*  (NO dots)
          # ECR repo rules: lowercase, digits, separators, NO dots. Keep it simple.
          RAW_APP="${APP_NAME}"
          SAFE_STACK_APP="$(echo "${RAW_APP}" | tr '._' '-' | tr -cd 'a-zA-Z0-9-' )"
          SAFE_ACTOR="$(echo "${GITHUB_ACTOR}" | tr -cd 'a-zA-Z0-9-' )"
          STACK_NAME="${SAFE_STACK_APP}-ec2-${SAFE_ACTOR}-${GITHUB_RUN_ID}"

          # ECR: lowercase, replace dots/underscores with hyphen, strip invalid chars.
          SAFE_ECR="$(echo "${ECR_REPO_RAW}" | tr '[:upper:]' '[:lower:]' | tr '._' '-' | tr -cd 'a-z0-9/-' | sed 's#//*#/#g' | sed 's#^-##; s#-$##')"
          # If they passed something odd and it becomes empty, fallback:
          if [[ -z "${SAFE_ECR}" ]]; then SAFE_ECR="petstore-api"; fi

          echo "STACK_NAME=${STACK_NAME}" >> "$GITHUB_ENV"
          echo "SANITIZED_ECR_REPO=${SAFE_ECR}" >> "$GITHUB_ENV"

          echo "stack_name=${STACK_NAME}" >> "$GITHUB_OUTPUT"
          echo "ecr_repo=${SAFE_ECR}" >> "$GITHUB_OUTPUT"

          echo "STACK_NAME set to: ${STACK_NAME}"
          echo "SANITIZED_ECR_REPO set to: ${SAFE_ECR}"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy CloudFormation stack
        shell: bash
        run: |
          set -euo pipefail
          aws cloudformation deploy \
            --stack-name "${STACK_NAME}" \
            --template-file "${TEMPLATE_FILE}" \
            --parameter-overrides \
              "AMIId=${{ vars.AMI_ID }}" \
              "InstanceType=${{ vars.INSTANCE_TYPE }}" \
              "SubnetId=${{ vars.SUBNET_ID }}" \
              "SecurityGroupIds=${{ vars.SG_IDS }}" \
              "IamInstanceProfileName=${{ vars.INSTANCE_PROFILE_NAME }}" \
              "KeyName=${{ vars.KEY_NAME }}" \
              "DeployTagKey=DemoOwner" \
              "DeployTagValue=${DEMO_OWNER}" \
              "AppName=${APP_NAME}" \
              "TlsMode=${TLS_MODE}" \
              "ImageTag=${IMAGE_TAG}" \
            --no-fail-on-empty-changeset \
            --region "${AWS_REGION}"

      - name: Resolve EC2 InstanceId
        id: cfnout
        shell: bash
        run: |
          set -euo pipefail
          # Your template's logical resource id is ApiInstance
          INSTANCE_ID="$(aws cloudformation describe-stack-resources \
            --stack-name "${STACK_NAME}" \
            --region "${AWS_REGION}" \
            --query "StackResources[?LogicalResourceId=='ApiInstance'].PhysicalResourceId" \
            --output text)"
          [[ -n "${INSTANCE_ID}" && "${INSTANCE_ID}" != "None" ]] || { echo "ERROR: no InstanceId"; exit 1; }
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"
          echo "InstanceId=${INSTANCE_ID}"

      - name: Wait for instance checks
        shell: bash
        run: |
          set -euo pipefail
          aws ec2 wait instance-status-ok --instance-ids "${{ steps.cfnout.outputs.instance_id }}" --region "${AWS_REGION}"

      - name: Resolve Public IP
        id: pubip
        shell: bash
        run: |
          set -euo pipefail
          PUBLIC_IP="$(aws ec2 describe-instances \
            --instance-ids "${{ steps.cfnout.outputs.instance_id }}" \
            --region "${AWS_REGION}" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)"
          [[ -n "${PUBLIC_IP}" && "${PUBLIC_IP}" != "None" ]] || { echo "ERROR: no Public IP"; exit 1; }
          echo "public_ip=${PUBLIC_IP}" >> "$GITHUB_OUTPUT"
          echo "PublicIp=${PUBLIC_IP}"

      - name: Update Route 53 A record + Print DAST Target
        id: dns
        shell: bash
        env:
          PUBLIC_IP: ${{ steps.pubip.outputs.public_ip }}
        run: |
          set -euo pipefail

          DNS_NAME="${APP_NAME}.${SA_ACRONYM}.${DNS_BASE_DOMAIN}"
          DAST_URL="https://${DNS_NAME}"

          aws route53 change-resource-record-sets \
            --hosted-zone-id "${HOSTED_ZONE_ID}" \
            --change-batch "{
              \"Comment\": \"GitHub Actions demo DNS update\",
              \"Changes\": [{
                \"Action\": \"UPSERT\",
                \"ResourceRecordSet\": {
                  \"Name\": \"${DNS_NAME}\",
                  \"Type\": \"A\",
                  \"TTL\": ${DNS_TTL},
                  \"ResourceRecords\": [{\"Value\": \"${PUBLIC_IP}\"}]
                }
              }]
            }" >/dev/null

          echo "dns_name=${DNS_NAME}" >> "$GITHUB_OUTPUT"
          echo "dast_url=${DAST_URL}" >> "$GITHUB_OUTPUT"

          echo ""
          echo "============================================================"
          echo "  ✅ PERMANENT DAST TARGET:"
          echo "     ${DAST_URL}"
          echo "============================================================"
          echo ""

          {
            echo "## ✅ Permanent DAST Target"
            echo ""
            echo "**DAST URL:** ${DAST_URL}"
            echo ""
            echo "**DNS A record:** \`${DNS_NAME}\` → \`${PUBLIC_IP}\`"
            echo ""
            echo "**TLS mode:** \`${TLS_MODE}\`"
            echo ""
            echo "### Quick checks"
            echo "\`\`\`bash"
            echo "dig ${DNS_NAME} +short"
            echo "curl -vk ${DAST_URL}/tls-info"
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"

  build-and-push:
    runs-on: ubuntu-latest
    needs: provision-ec2-cfn
    permissions:
      id-token: write
      contents: read
    outputs:
      image_uri: ${{ steps.img.outputs.image_uri }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute IMAGE_URI
        id: img
        shell: bash
        run: |
          set -euo pipefail
          # Use sanitized ECR repo from provision job output
          ECR_REPO="${{ needs.provision-ec2-cfn.outputs.ecr_repo }}"
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${IMAGE_TAG}"
          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_ENV"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "Using IMAGE_URI=${IMAGE_URI}"

      - name: Ensure ECR repository exists
        shell: bash
        run: |
          set -euo pipefail
          ECR_REPO="${{ needs.provision-ec2-cfn.outputs.ecr_repo }}"
          aws ecr describe-repositories --repository-names "${ECR_REPO}" --region "${AWS_REGION}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${ECR_REPO}" --region "${AWS_REGION}" >/dev/null

      - name: Login to ECR
        shell: bash
        run: |
          set -euo pipefail
          aws ecr get-login-password --region "${AWS_REGION}" | \
            docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build docker image
        shell: bash
        run: |
          set -euo pipefail
          docker build -t "${IMAGE_URI}" .

      - name: Push docker image
        shell: bash
        run: |
          set -euo pipefail
          docker push "${IMAGE_URI}"

  deploy-to-ec2:
    runs-on: ubuntu-latest
    needs: [provision-ec2-cfn, build-and-push]
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy container via SSM
        shell: bash
        env:
          INSTANCE_ID: ${{ needs.provision-ec2-cfn.outputs.instance_id }}
          IMAGE_URI: ${{ needs.build-and-push.outputs.image_uri }}
        run: |
          set -euo pipefail

          echo "Deploying to ${INSTANCE_ID}"
          echo "IMAGE_URI=${IMAGE_URI}"

          CMD_ID="$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy ${IMAGE_URI}" \
            --parameters commands="set -euo pipefail
              aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
              docker pull ${IMAGE_URI}
              docker rm -f petstore 2>/dev/null || true
              docker run -d --name petstore --restart unless-stopped -p 127.0.0.1:5000:5000 ${IMAGE_URI}
              sudo nginx -t
              sudo systemctl restart nginx
              curl -sk https://127.0.0.1/tls-info || true
            " \
            --query "Command.CommandId" --output text)"

          echo "SSM CommandId=${CMD_ID}"
          aws ssm wait command-executed --command-id "${CMD_ID}" --instance-id "${INSTANCE_ID}"

          aws ssm get-command-invocation \
            --command-id "${CMD_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "{Status:Status,Stdout:StandardOutputContent,Stderr:StandardErrorContent}" \
            --output json

      - name: Final DAST Target Summary
        shell: bash
        run: |
          set -euo pipefail
          DAST_URL="${{ needs.provision-ec2-cfn.outputs.dast_url }}"
          {
            echo "## ✅ Deployment Complete"
            echo ""
            echo "**Permanent DAST URL:** ${DAST_URL}"
            echo ""
            echo "Try:"
            echo "\`\`\`bash"
            echo "curl -vk ${DAST_URL}/tls-info"
            echo "curl -vk ${DAST_URL}/"
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"

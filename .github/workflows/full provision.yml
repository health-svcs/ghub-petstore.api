name: Provision EC2 + Build & Deploy petstore-api

on:
  workflow_dispatch:
    inputs:
      SA_ACRONYM:
        description: "3-letter SA acronym for stable DNS (agc, elg, etc)"
        required: true
        default: "agc"
        type: string

      TlsMode:
        description: "TLS posture applied at deploy time (NGINX): Weak or Secure"
        required: true
        default: "Weak"
        type: choice
        options:
          - Weak
          - Secure

  push:
    branches: ["main"]

env:
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ vars.AWS_REGION }}

  # ECR repo can be a variable; if missing, default to a sensible name
  ECR_REPO: ${{ vars.ECR_REPO || 'petstore-api' }}

  # Unique image tag per workflow run (prevents collisions across SAs)
  IMAGE_TAG: ${{ github.run_id }}

  TEMPLATE_FILE: cloudformation/ec2.yaml

  # Per-SA isolation tag (defaults to the person who triggered the run)
  DEMO_OWNER: ${{ vars.DEMO_OWNER || github.actor }}

  # DNS
  DNS_BASE_DOMAIN: ${{ vars.DNS_BASE_DOMAIN || 'sa.livedemo-us.com' }}
  DNS_TTL: ${{ vars.DNS_TTL || '60' }}

jobs:
  ###############################
  # 0. VALIDATE INPUTS          #
  ###############################
  validate-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Validate required repo/org variables
        shell: bash
        run: |
          set -euo pipefail

          require() {
            local name="$1"
            local val="$2"
            if [[ -z "${val}" ]]; then
              echo "ERROR: Required variable '${name}' is empty or not set."
              exit 1
            fi
          }

          require "AWS_ACCOUNT_ID" "${AWS_ACCOUNT_ID}"
          require "AWS_REGION" "${AWS_REGION}"
          require "ECR_REPO" "${ECR_REPO}"
          require "AWS_ROLE_TO_ASSUME" "${{ vars.AWS_ROLE_TO_ASSUME }}"
          require "AMI_ID" "${{ vars.AMI_ID }}"
          require "INSTANCE_TYPE" "${{ vars.INSTANCE_TYPE }}"
          require "SUBNET_ID" "${{ vars.SUBNET_ID }}"
          require "SG_IDS" "${{ vars.SG_IDS }}"
          require "INSTANCE_PROFILE_NAME" "${{ vars.INSTANCE_PROFILE_NAME }}"
          require "KEY_NAME" "${{ vars.KEY_NAME }}"

          # DNS vars (required for Route 53 updates)
          require "HOSTED_ZONE_ID" "${{ vars.HOSTED_ZONE_ID }}"

          echo "github.actor=${GITHUB_ACTOR}"
          echo "Resolved DEMO_OWNER=${DEMO_OWNER}"
          echo "DNS_BASE_DOMAIN=${DNS_BASE_DOMAIN}"
          echo "DNS_TTL=${DNS_TTL}"

          # Protect shared VRM tenant from scheduled/bot runs accidentally tagging everything as github-actions
          if [[ "${DEMO_OWNER}" == "github-actions" || "${DEMO_OWNER}" == *"[bot]" ]]; then
            echo "ERROR: Refusing to provision demo assets for automation actor: ${DEMO_OWNER}"
            echo "If intentional, set repo/org variable DEMO_OWNER to a human/team value."
            exit 1
          fi

          echo "Using IMAGE_TAG=${IMAGE_TAG}"
          echo "All required variables present."

  ###############################
  # 1. PROVISION EC2 FROM AMI   #
  ###############################
  provision-ec2-cfn:
    runs-on: ubuntu-latest
    needs: validate-inputs
    permissions:
      id-token: write
      contents: read
    env:
      STACK_NAME: petstore-ec2-${{ github.actor }}-${{ github.run_id }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy CloudFormation stack (with TLS mode + DemoOwner tag + ImageTag)
        shell: bash
        run: |
          set -euo pipefail
          set -x

          TLS_MODE_INPUT="${{ inputs.TlsMode || 'Weak' }}"

          echo "STACK_NAME='${STACK_NAME}'"
          echo "AWS_REGION='${AWS_REGION}'"
          echo "TEMPLATE_FILE='${TEMPLATE_FILE}'"
          echo "DEMO_OWNER='${DEMO_OWNER}'"
          echo "TlsMode='${TLS_MODE_INPUT}'"
          echo "ImageTag='${IMAGE_TAG}'"

          ls -l "${TEMPLATE_FILE}"

          aws cloudformation deploy \
            --stack-name "${STACK_NAME}" \
            --template-file "${TEMPLATE_FILE}" \
            --parameter-overrides \
              "AMIId=${{ vars.AMI_ID }}" \
              "InstanceType=${{ vars.INSTANCE_TYPE }}" \
              "SubnetId=${{ vars.SUBNET_ID }}" \
              "SecurityGroupIds=${{ vars.SG_IDS }}" \
              "IamInstanceProfileName=${{ vars.INSTANCE_PROFILE_NAME }}" \
              "KeyName=${{ vars.KEY_NAME }}" \
              "DeployTagKey=DemoOwner" \
              "DeployTagValue=${DEMO_OWNER}" \
              "TlsMode=${TLS_MODE_INPUT}" \
              "ImageTag=${IMAGE_TAG}" \
            --no-fail-on-empty-changeset \
            --region "${AWS_REGION}"

      - name: Resolve EC2 InstanceId (from stack resources)
        id: cfnout
        shell: bash
        run: |
          set -euo pipefail

          INSTANCE_ID="$(aws cloudformation describe-stack-resources \
            --stack-name "${STACK_NAME}" \
            --region "${AWS_REGION}" \
            --query "StackResources[?LogicalResourceId=='PetstoreInstance'].PhysicalResourceId" \
            --output text)"

          if [[ -z "${INSTANCE_ID}" || "${INSTANCE_ID}" == "None" ]]; then
            echo "ERROR: Failed to resolve EC2 InstanceId (got: '${INSTANCE_ID}')"
            aws cloudformation describe-stack-resources --stack-name "${STACK_NAME}" --region "${AWS_REGION}" --output json
            exit 1
          fi

          echo "InstanceId=${INSTANCE_ID}"
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"

      - name: Wait for EC2 instance checks
        shell: bash
        run: |
          set -euo pipefail
          aws ec2 wait instance-status-ok \
            --instance-ids "${{ steps.cfnout.outputs.instance_id }}" \
            --region "${AWS_REGION}"
          echo "EC2 instance is status-ok."

      - name: Resolve Public IP (from EC2 describe-instances)
        id: pubip
        shell: bash
        run: |
          set -euo pipefail

          INSTANCE_ID="${{ steps.cfnout.outputs.instance_id }}"

          PUBLIC_IP="$(aws ec2 describe-instances \
            --instance-ids "${INSTANCE_ID}" \
            --region "${AWS_REGION}" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)"

          if [[ -z "${PUBLIC_IP}" || "${PUBLIC_IP}" == "None" ]]; then
            echo "ERROR: Public IP not assigned yet (got: '${PUBLIC_IP}'). Is the instance in a public subnet with auto-assign public IP or an EIP?"
            aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" --region "${AWS_REGION}" --output json
            exit 1
          fi

          echo "PUBLIC_IP=${PUBLIC_IP}"
          echo "public_ip=${PUBLIC_IP}" >> "$GITHUB_OUTPUT"

      - name: Update Route 53 A record (DEMO_OWNER -> Public IP)
        id: dns
        shell: bash
        env:
          HOSTED_ZONE_ID: ${{ vars.HOSTED_ZONE_ID }}
          PUBLIC_IP: ${{ steps.pubip.outputs.public_ip }}
        run: |
          set -euo pipefail

          DNS_NAME="${DEMO_OWNER}.${DNS_BASE_DOMAIN}"
          echo "Updating DNS: ${DNS_NAME} -> ${PUBLIC_IP}"

          aws route53 change-resource-record-sets \
            --hosted-zone-id "${HOSTED_ZONE_ID}" \
            --change-batch "{
              \"Comment\": \"GitHub Actions demo DNS update\",
              \"Changes\": [{
                \"Action\": \"UPSERT\",
                \"ResourceRecordSet\": {
                  \"Name\": \"${DNS_NAME}\",
                  \"Type\": \"A\",
                  \"TTL\": ${DNS_TTL},
                  \"ResourceRecords\": [{\"Value\": \"${PUBLIC_IP}\"}]
                }
              }]
            }" >/dev/null

          echo "dns_name=${DNS_NAME}" >> "$GITHUB_OUTPUT"

    outputs:
      instance_id: ${{ steps.cfnout.outputs.instance_id }}
      public_ip: ${{ steps.pubip.outputs.public_ip }}
      dns_name: ${{ steps.dns.outputs.dns_name }}

  #########################################
  # 2. BUILD & PUSH IMAGE TO ECR          #
  #########################################
  build-and-push:
    runs-on: ubuntu-latest
    needs: provision-ec2-cfn
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute IMAGE_URI
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${IMAGE_TAG}"
          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_ENV"
          echo "Using IMAGE_URI=${IMAGE_URI}"

      - name: Ensure ECR repository exists
        shell: bash
        run: |
